#
# Copyright (c) 2013 Juniper Networks, Inc. All rights reserved.
#

class TypeClassGenerator(object):
    def __init__(self, cTypeDict):
        self._cTypeDict = cTypeDict
        self._generated_types = { }

    def _GenerateTypeSub(self, file, ctype):
        depend_types = ctype.getDependentTypes()
        for child in depend_types:
            if not child.getName() in self._generated_types:
                self._generated_types[child.getName()] = child
                self._GenerateTypeSub(file, child)

        file.write('\nstruct %s : public AutogenProperty {\n' % ctype.getName())

        file.write('    virtual ~%s();\n' % ctype.getName())

        members = ctype.getDataMembers()
        if len(members) == 1 and members[0].isSequence:
            member = members[0]
            cdecl = """
    typedef %(vectype)s::const_iterator const_iterator;
    const_iterator begin() const { return %(membername)s.begin(); }
    const_iterator end() const { return %(membername)s.end(); }
"""  % {'vectype': member.ctypename, 'membername': member.membername}
            file.write(cdecl)
        
        for member in ctype.getDataMembers():
            file.write('    %s %s;\n' % (member.ctypename, member.membername))
        tail = """
    void Clear();
    void Copy(const %s &rhs);
    bool XmlParse(const pugi::xml_node &node);
    static bool XmlParseProperty(const pugi::xml_node &node,
                                 std::auto_ptr<AutogenProperty> *resultp);
    void Encode(pugi::xml_node *node) const;
};
""" % (ctype.getName())
        file.write(tail)

    def GenerateType(self, file, ctype):
        if not ctype.getName() in self._generated_types:
            self._generated_types[ctype.getName()] = ctype
            self._GenerateTypeSub(file, ctype)

    def Generate(self, file, ctype):
        header = """
// autogenerated file --- DO NOT EDIT ---
#include <iostream>
#include <string.h>
#include <vector>

#include <boost/dynamic_bitset.hpp>
namespace pugi {
class xml_node;
class xml_document;
}  // namespace pugi

#include "ifmap/autogen.h"

namespace autogen {

"""
        file.write(header)
        self.GenerateType(file, ctype)
        file.write('}  // namespace autogen\n')
        pass

class TypeImplGenerator(object):
    def __init__(self, cTypeDict):
        self._cTypeDict = cTypeDict
        pass

    def GenerateType(self, file, ctype):
        destruct = """
%(class)s::~%(class)s() {
}
""" % {'class': ctype.getName()}
        file.write(destruct)

        cleardef = """
void %s::Clear() {
""" % ctype.getName()
        file.write(cleardef)
        for member in ctype.getDataMembers():
            cpptype = member.ctypename
            if (cpptype == 'int' or
                cpptype == 'uint64_t' or
                cpptype == 'time_t'):
                file.write('    %s = 0;\n' % member.membername)
            elif cpptype == 'bool':
                file.write('    %s = false;\n' % member.membername)
            elif member.isComplex and not member.isSequence:
                file.write('    %s.Clear();\n' % member.membername)
            else:
                file.write('    %s.clear();\n' % member.membername)
        file.write('};\n')

        copydef = """
void %s::Copy(const %s &rhs) {
""" % (ctype.getName(), ctype.getName())
        file.write(copydef)
        for member in ctype.getDataMembers():
            cpptype = member.ctypename
            if member.isComplex and not member.isSequence:
                fmt = '    %s.Copy(rhs.%s);\n'
            else:
                fmt = '    %s = rhs.%s;\n'
            file.write(fmt % (member.membername, member.membername))

        file.write('};\n')

    def Generate(self, hdrname, file):
        header = """
// autogenerated file --- DO NOT EDIT ---
#include "%s"

#include <boost/bind.hpp>
#include "ifmap/autogen.h"

#include <pugixml/pugixml.hpp>

using namespace std;

namespace autogen {
""" % hdrname
        file.write(header)

        for ctype in self._cTypeDict.values():
            self.GenerateType(file, ctype)
        file.write('}\n')
